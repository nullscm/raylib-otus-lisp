(import (file xml)(scheme file))
;; filter numbers from string
(define (digit? x) (<= #\0 x #\9))
(define (number-filter lst) (cond ((null? lst) lst) ((or (eq? #\space (car lst)) (digit? (car lst))) (cons (car lst) (number-filter (cdr lst)))) (else (number-filter (cdr lst)))))
(define filter-numbers (lambda (lst) (list->string (number-filter (string->list lst)))))
;; check if string contains substring
(define (string-contains s t) (let* ((len (string-length s)) (max (- (string-length t) len))) (let loop ((i 0)) (cond ((> i max) #f) ((string=? s (substring t i (+ i len))) i) (else (loop (+ i 1)))))))
;; split string by #\space
(define (tokenize l) (let loop ((t '()) (l l)) (if (pair? l) (let ((c (car l))) (if (char=? c #\space) (cons (reverse t) (loop '() (cdr l))) (loop (cons (car l) t) (cdr l)))) (if (null? t) '() (list (reverse t))))))
(define (string-split s) (map list->string (tokenize (string->list s))))
;; download raylib_api.xml
(if (not (file-exists? "raylib_api.xml")) (syscall 1017 (c-string "wget https://raw.githubusercontent.com/raysan5/raylib/master/parser/output/raylib_api.xml") #f #f))
;; load raylib_api.xml
(define xml (xml-get-root-element (xml-parse-file "raylib_api.xml")))
(define enums (xml-get-subtags xml 'Enums))
(define enums (xml-get-subtags (ref enums 1) 'Enum))
(define structs (xml-get-subtags xml 'Structs))
(define structs (xml-get-subtags (ref structs 1) 'Struct))
(define defines (xml-get-subtags xml 'Defines))
(define defines (xml-get-subtags (ref defines 1) 'Define))
(define aliases (xml-get-subtags xml 'Aliases))
(define aliases (xml-get-subtags (ref aliases 1) 'Alias))
(define funcs (xml-get-subtags xml 'Functions))
(define funcs (xml-get-subtags (ref funcs 1) 'Function))
(define %convert-to-fft-enum (append (map (lambda (struct) (xml-get-attribute struct 'name "")) structs) '()))
(define (convert port type)
  (if (string-contains "float" type) (display " fft-float" port ))
  (if (string-contains "int" type) (display " fft-int" port ))
  (if (string-contains "bool" type) (display " fft-bool" port ))
  (if (string-contains "void" type) (display " fft-void" port ))
  (if (string-contains "short" type) (display " fft-short" port))
  (if (string-contains "rAudioBuffer" type) (display " fft-any" port))
  (if (string-contains "rAudioProcessor" type) (display " fft-any" port))
  (if (string-contains "long" type) (display " fft-long" port))
  (if (string-contains "double" type) (display " fft-double" port))
  (if (string-contains "char" type) (display " type-string" port))
  (if (string-contains "Quaternion" type) (display " Vector4" port))
  (if (equal? "Texture2D" type) (display " Texture" port))
  (if (string-contains "TextureCubemap" type) (display " Texture" port))
  (if (string-contains "RenderTexture2D" type) (display " RenderTexture" port) )
  (if (pair? (cdr (string-split type))) (if (member (car (cdr (string-split type))) %convert-to-fft-enum) (display (string-append " " (car (cdr (string-split type)))) port) ))
  (if (member (car (string-split type)) %convert-to-fft-enum) (display (string-append " " (car (string-split type))) port) )
  (if (string-contains "*" type) (and (not (member (car (string-split type)) %convert-to-fft-enum)) (display "" port)))
  (if (string-contains "void *" type) (and (not (member (car (string-split type)) %convert-to-fft-enum)) (display "*" port)))
  (if (string-contains "double *" type) (and (not (member (car (string-split type)) %convert-to-fft-enum)) (display "*" port)))
  (if (string-contains "float *" type) (and (not (member (car (string-split type)) %convert-to-fft-enum)) (display "*" port)))
  (if (string-contains "int *" type) (and (not (member (car (string-split type)) %convert-to-fft-enum)) (display "*" port)))
  )
(define (display-types-to port lst)
  (for-each
    (lambda (param)
      (let* ((t (assoc 'type (ff->alist (ref param 2))))
             (type (if (pair? t) (cdr t) t)))
        (convert port type)
        ))
    (car (cddr (vector->list lst)))))
;;;; Generate lib/raylib.scm file
;; create ./lib directory
(if (not (file-exists? "lib")) (syscall 1017 (c-string "mkdir lib") #f #f))
(define port (open-output-file "lib/raylib.scm"))
;; Define Library
(print-to port "(define-library (lib raylib) (import (otus lisp) (otus ffi)) (export ")
;; Colornames
(for-each 
  (lambda (define) 
    (if (equal? "COLOR" (xml-get-attribute define 'type #f)) (print-to port (xml-get-attribute define 'name #f))))
  defines)
;; Enums
(for-each (lambda (enum)
            (for-each (lambda (value)
                        (print-to port (xml-get-attribute value 'name "")))
                      (xml-get-subtags enum 'Value)))
          enums)
;;Structs
(for-each (lambda (struct) (print-to port (xml-get-attribute struct 'name ""))) structs)
;; Functionnames
(for-each (lambda (func) (print-to port (xml-get-attribute func 'name ""))) funcs)
(print-to port ")(cond-expand (Linux (begin (define raylib (load-dynamic-library \"libraylib.so\")) (define raylib-err \"Use, for example, sudo apt install libraylib.so\"))) (else (runtime-error \"unsupported platform\" (uname)))) (begin (if (not raylib) (runtime-error \"Can't load raylib library.\" raylib-err))")
;; Common Pointers
(print-to port "(define fft-float* (fft* fft-float))")
(print-to port "(define fft-void* (fft* fft-void))")
(print-to port "(define fft-int* (fft* fft-int))")
;;(print-to port "(define fft-enum* (fft* fft-enum))")
;;(print-to port "(define type-string* (fft* type-string))")
(print-to port "(define fft-double* (fft* fft-double))")
;;(print-to port "(define fft-long* (fft* fft-long))")
;;(print-to port "(define fft-short* (fft* fft-short))")
;; Structs 
(print-to port) (print-to port ";;;; Structs")
(for-each (lambda (x) (let ((name (xml-get-attribute x 'name #f)) 
                            (retType (xml-get-attribute x 'retType #t)))
                        (print-to port ";; " (xml-get-attribute x 'desc #f))
                        (display-to port (string-append "(define " name " (list "))
                        (display-types-to port x) (print-to port "))")))
          structs)
;; Aliases
;;(for-each (lambda (x) (let ((name (xml-get-attribute x 'name #t)) 
;; (type (xml-get-attribute x 'type #t)))
;; (print-to port ";; " (xml-get-attribute x 'desc #f))
;; (display-to port (string-append "(define " type " " name ")"))))
;; aliases)
;; Functions
(print-to port) (print-to port ";;;; Functions")
(for-each (lambda (x) (let ((name (xml-get-attribute x 'name #f)) 
                            (retType (xml-get-attribute x 'retType #t)))
                        (print-to port ";; " (xml-get-attribute x 'desc #f))
                        (display-to port (string-append "(define " name " (raylib "))
                        (convert port retType)
                        (display-to port (string-append " \"" name "\""))
                        (display-types-to port x) (print-to port "))")))
          funcs)
;; Enums
(print-to port) (print-to port ";;;; Enums")
(for-each (lambda (enum)
            (print-to port ";; " (xml-get-attribute enum 'name #f))
            (for-each (lambda (value)
                        (print-to port "(define " (xml-get-attribute value 'name "") " " (xml-get-attribute value 'integer "") ")"))
                      (xml-get-subtags enum 'Value)))
          enums)
;; Colors
(print-to port) (print-to port ";;;; Colors")
(for-each 
  (lambda (define)
    (cond ((equal? "COLOR" (xml-get-attribute define 'type #f))
           (print-to port "(define " (xml-get-attribute define 'name #f) " (list " 
                     (filter-numbers (xml-get-attribute define 'value #f)) "))")))) 
  defines)
(display "))" port)
(close-port port)
